"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chainLinkAsync = exports.chainAsync = exports.chainLink = exports.chain = void 0;

var _deepCopy = _interopRequireDefault(require("../../util/deepCopy"));

var _type = require("./type");

var _data = require("./data");

var _graph = require("./graph");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const chain = (input, options = {}) => {
  let _options$maxChainLeng = options.maxChainLength,
      maxChainLength = _options$maxChainLeng === void 0 ? 10 : _options$maxChainLeng,
      _options$generateGrap = options.generateGraph,
      generateGraph = _options$generateGrap === void 0 ? true : _options$generateGrap,
      forceType = options.forceType;
  let type = forceType || (0, _type.type)(input);
  let output = type.match(/object$/) ? (0, _deepCopy.default)(input) : input;
  const graph = [{
    type,
    data: input
  }];

  while (type !== '@csl/list+object') {
    if (maxChainLength-- <= 0) {
      logger.error('[set]', 'Max. number of parsing iterations reached');
      return [];
    }

    output = (0, _data.data)(output, type);
    type = (0, _type.type)(output);
    graph.push({
      type
    });
  }

  return output.map(generateGraph ? entry => (0, _graph.applyGraph)(entry, graph) : _graph.removeGraph);
};

exports.chain = chain;

const chainLink = input => {
  const type = (0, _type.type)(input);
  const output = type.match(/array|object/) ? (0, _deepCopy.default)(input) : input;
  return (0, _data.data)(output, type);
};

exports.chainLink = chainLink;

const chainAsync = function () {
  var _ref = _asyncToGenerator(function* (input, options = {}) {
    let _options$maxChainLeng2 = options.maxChainLength,
        maxChainLength = _options$maxChainLeng2 === void 0 ? 10 : _options$maxChainLeng2,
        _options$generateGrap2 = options.generateGraph,
        generateGraph = _options$generateGrap2 === void 0 ? true : _options$generateGrap2,
        forceType = options.forceType;
    let type = forceType || (0, _type.type)(input);
    let output = type.match(/array|object/) ? (0, _deepCopy.default)(input) : input;
    const graph = [{
      type,
      data: input
    }];

    while (type !== '@csl/list+object') {
      if (maxChainLength-- <= 0) {
        logger.error('[set]', 'Max. number of parsing iterations reached');
        return [];
      }

      output = yield (0, _data.dataAsync)(output, type);
      type = (0, _type.type)(output);
      graph.push({
        type
      });
    }

    return output.map(generateGraph ? entry => (0, _graph.applyGraph)(entry, graph) : _graph.removeGraph);
  });

  return function chainAsync(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.chainAsync = chainAsync;

const chainLinkAsync = function () {
  var _ref2 = _asyncToGenerator(function* (input) {
    const type = (0, _type.type)(input);
    let output = type.match(/array|object/) ? (0, _deepCopy.default)(input) : input;
    return (0, _data.dataAsync)(output, type);
  });

  return function chainLinkAsync(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

exports.chainLinkAsync = chainLinkAsync;