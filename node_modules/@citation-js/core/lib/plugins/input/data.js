"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listDataParser = exports.removeDataParser = exports.hasDataParser = exports.addDataParser = exports.dataAsync = exports.data = void 0;

var _chain = require("./chain");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const flatten = array => [].concat(...array);

const parsers = {};
const asyncParsers = {};
const nativeParsers = {
  '@csl/object': input => [input],
  '@csl/list+object': input => input,
  '@else/list+object': input => flatten(input.map(_chain.chain)),
  '@invalid': () => []
};
const nativeAsyncParsers = {
  '@else/list+object': function () {
    var _elseListObject = _asyncToGenerator(function* (input) {
      return flatten((yield Promise.all(input.map(_chain.chainAsync))));
    });

    return function elseListObject(_x) {
      return _elseListObject.apply(this, arguments);
    };
  }()
};

const data = (input, type) => {
  if (parsers.hasOwnProperty(type)) {
    return parsers[type](input);
  } else if (nativeParsers.hasOwnProperty(type)) {
    return nativeParsers[type](input);
  } else {
    logger.error('[set]', `No synchronous parser found for ${type}`);
    return null;
  }
};

exports.data = data;

const dataAsync = function () {
  var _ref = _asyncToGenerator(function* (input, type) {
    if (asyncParsers.hasOwnProperty(type)) {
      return asyncParsers[type](input);
    } else if (nativeAsyncParsers.hasOwnProperty(type)) {
      return nativeAsyncParsers[type](input);
    } else if (hasDataParser(type, false)) {
      return data(input, type);
    } else {
      logger.error('[set]', `No parser found for ${type}`);
      return null;
    }
  });

  return function dataAsync(_x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

exports.dataAsync = dataAsync;

const addDataParser = (format, {
  parser,
  async
}) => {
  if (async) {
    asyncParsers[format] = parser;
  } else {
    parsers[format] = parser;
  }
};

exports.addDataParser = addDataParser;

const hasDataParser = (type, async) => async ? asyncParsers[type] || nativeAsyncParsers[type] : parsers[type] || nativeParsers[type];

exports.hasDataParser = hasDataParser;

const removeDataParser = (type, async) => {
  delete (async ? asyncParsers : parsers)[type];
};

exports.removeDataParser = removeDataParser;

const listDataParser = async => Object.keys(async ? asyncParsers : parsers);

exports.listDataParser = listDataParser;